// Prisma schema for SQLite storage adapter
// Generated by aaow storage-adapter-sqlite

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Workflow definitions stored as complete JSON documents
model Workflow {
  id         String   @id
  name       String
  version    String
  definition String   // JSON serialized Workflow
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  metadata   String?  // JSON

  // Relations
  sessions Session[]

  @@index([name])
  @@index([version])
  @@map("workflows")
}

// Session (Workflow Run) with snapshot of workflow definition
model Session {
  id               String   @id
  workflowId       String?
  workflowSnapshot String   // JSON serialized Workflow
  status           String   // SessionStatus enum
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  metadata         String?  // JSON

  // Relations
  workflow          Workflow?           @relation(fields: [workflowId], references: [id], onDelete: SetNull)
  executionState    ExecutionState?
  llmExecutions     LLMExecution[]
  approvalRequests  ApprovalRequest[]
  nodeStates        NodeExecutionState[]

  @@index([workflowId])
  @@index([status])
  @@index([createdAt])
  @@map("sessions")
}

// Workflow execution state with runtime context
model ExecutionState {
  id             String   @id @default(cuid())
  sessionId      String   @unique
  budgetPoolId   String?
  currentNodeId  String?
  status         String   // SessionStatus enum
  startedAt      DateTime @default(now())
  completedAt    DateTime?
  metadata       String?  // JSON - contains full ExecutionContext data

  // Relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("execution_states")
}

// Node execution state within a workflow run
model NodeExecutionState {
  id                 String    @id @default(cuid())
  sessionId          String
  nodeId             String
  status             String    // NodeExecutionStatus enum
  input              String?   // JSON
  output             String?   // JSON
  error              String?
  startedAt          DateTime?
  completedAt        DateTime?
  retryCount         Int       @default(0)
  pendingApprovalId  String?
  metadata           String?   // JSON

  // Relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, nodeId])
  @@index([sessionId])
  @@index([status])
  @@map("node_execution_states")
}

// LLM execution results and logs
model LLMExecution {
  id                  String   @id
  sessionId           String
  nodeId              String
  timestamp           DateTime @default(now())
  success             Boolean
  text                String?
  toolCalls           String?  // JSON array of tool calls
  usage_promptTokens  Int?
  usage_completionTokens Int?
  usage_totalTokens   Int?
  error               String?
  metadata            String?  // JSON (model, temperature, etc.)

  // Relations
  session   Session       @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  toolCallLogs ToolCallLog[]

  @@index([sessionId])
  @@index([nodeId])
  @@index([timestamp])
  @@map("llm_executions")
}

// Budget pools for hierarchical cost control
model BudgetPool {
  id               String   @id
  parentPoolId     String?
  totalBudget      Float
  usedBudget       Float
  remainingBudget  Float
  status           String   // BudgetPoolStatus enum
  createdAt        DateTime @default(now())
  metadata         String?  // JSON

  // Self-relation for hierarchy
  parent   BudgetPool?  @relation("BudgetPoolHierarchy", fields: [parentPoolId], references: [id])
  children BudgetPool[] @relation("BudgetPoolHierarchy")

  @@index([parentPoolId])
  @@index([status])
  @@map("budget_pools")
}

// Tool call logs
model ToolCallLog {
  id           String   @id
  executionId  String
  toolCallId   String
  toolName     String
  args         String   // JSON
  result       String?  // JSON
  error        String?
  timestamp    DateTime @default(now())
  duration     Int?     // milliseconds

  // Relations
  execution LLMExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  @@index([executionId])
  @@index([toolName])
  @@index([timestamp])
  @@map("tool_call_logs")
}

// Approval requests for human-in-the-loop workflows
model ApprovalRequest {
  id              String    @id
  sessionId       String
  nodeId          String
  type            String    // ApprovalType enum
  status          String    // ApprovalStatus enum
  context         String    // JSON - approval context
  createdAt       DateTime  @default(now())
  resolvedAt      DateTime?
  resolvedBy      String?
  resolutionNotes String?

  // Relations
  session Session @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@map("approval_requests")
}

// Stream events for reactive data processing (optional)
model StreamEvent {
  id        String   @id
  streamId  String
  nodeId    String
  data      String   // JSON
  timestamp DateTime @default(now())

  @@index([streamId])
  @@index([timestamp])
  @@map("stream_events")
}
